/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <map>
#include <memory>
#include <ostream>
#include <string>
#include <variant>
#include <vector>

#include "flashlight/fl/tensor/Index.h"
#include "flashlight/fl/tensor/TensorBase.h"

namespace fl {

/**
 * An interface for implementing custom tracers on Tensor operations.
 *
 * Tracers must be able to receive arguments of any types present in the Tensor
 * API. These are enumerated in the ArgumentTypes variant and can be expanded as
 * the API changes.
 *
 * Tracing data is passed via maps of string key names to ArgumentTypes. Traced
 * tensor operations created via trace(...) have three parts:
 * 1. general operation argument metadata
 * 2. input data to operators
 * 3. output data generated by an operator
 *
 * Operations are written to a std::ostream which is owned by the tracer. To
 * multiplex ostreams, multiple tracer instances should be used in cases where
 * tracers don't own internal state.
 */
class TracerBase {
  std::unique_ptr<std::ostream> ostream_;

 protected:
  bool tracingEnabled_{true};

 public:
  TracerBase() = default;
  virtual ~TracerBase() = default;

  /**
   * Construct a TracerBase.
   *
   * @param[in] stream an ostream pointer that the tracer will own and write to
   */
  explicit TracerBase(std::unique_ptr<std::ostream> stream);

  // A possible argument type to trace.
  using ArgumentTypes = std::variant<
      Tensor,
      Index,
      std::vector<Index>, // indices
      std::vector<int>, // axes
      std::vector<std::pair<int, int>>, // padWidths
      std::vector<Tensor>,
      double,
      int,
      bool,
      unsigned,
      long,
      unsigned long,
      unsigned long long,
      fl::dtype,
      Dim, // axis
      Shape,
      SortMode,
      PadType,
      MatrixProperty, // matmul
      Location, // i.e. memory
      StorageType // sparse
      >;
  using ArgumentList = std::map<
      std::string, // argument name
      ArgumentTypes>;

  void enableTracer(bool val);

  /**
   * @return if tracing is enabled
   */
  bool tracingEnabled() const;

  /**
   * Get a reference to the stream associated with this tracer.
   */
  const std::ostream& getStream() const;

  /**
   * Non-const getter for stream for use as an lvalue
   */
  std::ostream& getStream();

  /**
   * Set the stream associated with this tracer to which traces will be written
   * out.
   *
   * @param[in] stream a pointer to the new ostream to use.
   */
  void setStream(std::unique_ptr<std::ostream> stream);

  /**
   * Trace operations with a given name.
   *
   * @param[in] funcName the name of the op/function to trace
   * @param[in] args map of string-key delimited argument metadata to trace
   * @param[in] inputs map of string-key delimited input arguments to the
   * operator
   * @param[in] outputs map of string-key delimited output arguments to the
   * operator
   */
  virtual void trace(
      const std::string& /* funcName */,
      ArgumentList /* args */,
      ArgumentList /* inputs */,
      ArgumentList /* outputs */) {}
};

} // namespace fl
